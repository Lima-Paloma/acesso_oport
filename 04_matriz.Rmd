---
title: "Matriz de tempo"
author: "Ipea"
date: "27 de março de 2019"
output: github_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = "UTF-8") })
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE, eval = FALSE)


library(knitr)
library(readr)
library(dplyr)
library(readxl)
library(scales)
library(sf)
library(mapview)
library(data.table)
library(opentripplanner)
library(purrr)
library(httr)
library(furrr)
library(tidyr)
library(lubridate)

source("R/3-otp.R")
source("R/4-matriz_acessibilidade.R")
```

# Matriz de tempo de viagem

Foram desenvolvidos dois métodos para fazer consultas ao OTP e retornar uma matriz de tempo de viagem:

- Função ``matriz_acessibilidade``, desenvolvida nesse projeto, que faz consultas em paralelo ao ``router`` do OTP (``localhost``) (em R);
- Método em python (repo [aqui](https://github.com/rafapereirabr/otp-travel-time-matrix)), desenvolvida pelo [Rafael Pereira](https://github.com/rafapereirabr), que faz uso da interação entre Java e Python para fazer consultas ao OTP e retornar uma matriz de tempo de viagem.

## Benchmark 

Buscando escolher o método de melhor performance para o projeto, é feito um benchmark das alternativas. Para tanto, será utilizada uma amostra de 100 pontos da cidade de Fortaleza para avaliar qual dos dois método é melhor.

A função ``matriz_acessibilidade`` tem somente um argumento obrigatório, que é a cidade em questão. Além disso, é usado o argumento ``amostra``, que utilizará somente 100 pontos para a construção da matriz de tempo.

```{r R}

# ligar_servidor("fortaleza")

bench_r <- system.time(matriz_acessibilidade("fortaleza", ligar_otp = TRUE, amostra = TRUE))

```

Usando python:

```{r python fortaleza}

source("R/sfc_as_cols.R")

for_hex <- read_rds("../data/hex_municipio/hex_for.rds") %>%
  select(id_hex) %>%
  # Gerar somente 100 pontos
  # slice(1:100) %>%
  identity()

for_hex_centroids <- for_hex %>%
  st_centroid() %>%
  sfc_as_cols(names = c("X","Y")) %>%
  rename(GEOID = id_hex)

# salvar

write_csv(for_hex_centroids, "../otp/points/points_for.csv")

```

Agora rodando o comando para criar a matriz de tempo de viagem em python:

```{r python matriz}


setwd("../otp")

command <- "java -jar programs/jython.jar -Dpython.path=programs/otp.jar  py/python_script_for.py"

bench_py <- system.time(system(command))

system(command)

# para todos pontos: Elapsed time was 277.288 seconds

```

<!-- Resultado: o método em python levou cerca de 8 minutos enquanto que o método em python levou 4,5 minutos. -->

## Metodologia para a construção da matriz

Atestado que o método por python é mais veloz, é estabelecido então o método para a construção das matrizes de tempo de viagem usando o script em Python. O processo é dividido em três etapas: criação dos pontos de origem e destino, criação do script em python e aplicação do comando para iniciar o OTP.

### Criar pontos de origem para todas as cidades

É criada então uma função que gera os pontos de origem e destino e suas coordenadas (no formato requerido pelo OTP e script em Python), para cada uma das resoluções de hexágonos determinadas anteriormente. A partir do nome abreviado do município (``CIDADE``), a função extrai o centróide de cada hexágono para todas as resoluções (``RES``) e salva no disco o nome ``points_CIDADE_RES.csv`` na pasta ``../otp/points``.

```{r points res}

source("R/sfc_as_cols.R")

points_allres <- function(muni_shortname) {
  
  dir <- dir("../data/hex_municipio/", pattern = muni_shortname)
  
  res <- str_extract(dir, "\\d+")
  
  dir_muni <- paste0("../data/hex_municipio/hex_", muni_shortname, "_", res, ".rds")
  
  seila <- function(muni_res) {
    
    dir_muni <- muni_res
    
    res <- str_extract(dir_muni, "\\d+")
    
    # criar pontos
    hex_muni <- readRDS(dir_muni) %>%
      select(id_hex) %>%
      st_centroid() %>%
      sfc_as_cols(names = c("X","Y")) %>%
      rename(GEOID = id_hex)
    
    
    # salvar
    dir_output <- sprintf("../otp/points/points_%s_%s.csv", muni_shortname, res)
      
    write_csv(hex_muni, dir_output)
      
  }
  
  walk(dir_muni, seila)
  
}


```

###  Criar script em Python

A função ``criar_script_python`` cria um script em python na pasta ``../otp/py`` que é utilizado para gerar os tempos de viagem entre os pares OD, e precisa de três inputs: 

- ``municipio``: é a sigla do município desejado (três primeiras letras);
- ``data``: é a data de análise. Essa data deve estar dentro do intervalo ``start_date``e ``end_date`` de datas determinado no arquivo ``calendar.txt`` que está no GTFS que foi utilizado para construção do graph daquela cidade;
- ``res``: é a resolução de hexágonos desejada.

O formato final do script é ``otp_CIDADE_DATA_RES.py``.

```{r matriz for}

source("R/4-criar_script_python.R")

# dia = 2018-10-05

# criar arquivo python
criar_script_python("for", "2018-10-05", "09")
criar_script_python("for", "2018-10-05", "09")


```

### Aplicar comando para rodar OTP

Por fim, é necessário criar o comando para aplicar o OTP com o script em python. A função ``rodar_otp`` monta o comando a ser encaminhado para o Prompt de Comando, e toma como input a cidade, a data e a resolução desejada.

```{r fun_aplicar_otp}


aplicar_otp <- function(cidade, data, res = 8) {
  
  py_nome <- sprintf("otp_%s_%s_%s.py", cidade, data, res)
  
  comando <- sprintf("cd ../otp && java -jar programs/jython.jar -Dpython.path=programs/otp.jar py/%s", py_nome)
  
  shell(comando)
  
  
}


# # criar comando
# command <- "cd ../otp && java -jar programs/jython.jar -Dpython.path=programs/otp.jar  py/python_script_for_2018-10-05_09.py"


# Para resolução 09: Elapsed time was 2898.65 seconds

```

## Matriz de tempo de viagem

Por fim, para a construção da matriz de tempo de viagem, as três etapas da metodologia descritas acima são aplicadas. Primeiro são criados todos os pontos centróides dos hexágonos (para todas as resoluções), depois é criado o script em python, e por fim é rodado o OTP.

### Matriz para Fortaleza

Para Fortaleza:

```{r aplicar_otp_for}

# criar pontos
points_allres("for")

# criar arquivo python
criar_script_python("for", "2018-10-05", "09")

# aplicar otp
aplicar_otp("for", "2018-10-05", "09")

```

### Matriz para Belo Horizonte

Aplicando o método em python para Belo Horizonte (AINDA COM A METODOLOGIA ANTIGA):

```{r matriz bel}

source("R/sfc_as_cols.R")

# produzir pontos (centroids dos hexagonos)
read_rds("../data/hex_municipio/hex_bel.rds") %>%
  select(id_hex) %>%
  # Gerar somente 100 pontos
  # slice(1:100) %>%
  st_centroid() %>%
  sfc_as_cols(names = c("X","Y")) %>%
  rename(GEOID = id_hex)
  write_csv("../otp/points/points_bel.csv")



# aplicar

command <- "cd ../otp && java -jar programs/jython.jar -Dpython.path=programs/otp.jar  py/python_script_bel.py"

shell(command)

# Elapsed time was 446.081 seconds

```

### Matriz para o Rio de Janeiro

Aplicando para o Rio de Janeiro (AINDA COM A METODOLOGIA ANTIGA):

```{r matriz rio}

source("R/sfc_as_cols.R")

# produzir pontos (centroids dos hexagonos)
read_rds("../data/hex_municipio/hex_rio.rds") %>%
  select(id_hex) %>%
  # Gerar somente 100 pontos
  # slice(1:100) %>%
  st_centroid() %>%
  sfc_as_cols(names = c("X","Y")) %>%
  rename(GEOID = id_hex) %>%
  write_csv("../otp/points/points_rio.csv")



# aplicar

command <- "cd ../otp && java -jar programs/jython.jar -Dpython.path=programs/otp.jar  py/python_script_rio.py"

shell(command)

# Elapsed time was 502.98 seconds

```

## Método para coleta de tempo de viagem a cada 15 minutos

Para Fortaleza:

```{r python loop for}

command <- "cd ../otp && java -jar programs/jython.jar -Dpython.path=programs/otp.jar  py/python_script_loopHM_for.py"

system(command)

```

